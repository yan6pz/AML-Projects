library("forecast")
rainseriesforecasts2 <- forecast.HoltWinters(rainseriesforecasts, h=8)
rainseriesforecasts2
plot.forecast(rainseriesforecasts2)
plot.forecast(rainseriesforecasts2)
library("TTR")
kings <- scan("D:/Machine Learning A-Z/Time series/kings.dat",skip=3)
kingstimeseries <- ts(kings)
plot.ts(kingstimeseries)
births <- scan("http://robjhyndman.com/tsdldata/data/nybirths.dat")
#twelve months starting from january 1946
birthstimeseries <- ts(births, frequency=12, start=c(1946,1))
plot.ts(birthstimeseries)
birthstimeseriescomponents <- decompose(birthstimeseries)
birthstimeseriescomponents$seasonal
birthstimeseriescomponents$trend
birthstimeseriescomponents$random
plot(birthstimeseriescomponents)
library("TTR")
kingstimeseriesSMA3 <- SMA(kingstimeseries,n=3) #simple moving average 3, used when a lot of data and fluctuations are present
plot.ts(kingstimeseriesSMA3)
rain <- scan("http://robjhyndman.com/tsdldata/hurst/precip1.dat",skip=1)
rainseries <- ts(start=c(1813),rain)
plot.ts(rainseries)
rainseriesforecasts <- HoltWinters(rainseries, beta=FALSE, gamma=FALSE)
rainseriesforecasts
rainseriesforecasts$fitted
plot(rainseriesforecasts)
library("forecast")
rainseriesforecasts2 <- forecast.HoltWinters(rainseriesforecasts, h=8) #future forecast 8 years
rainseriesforecasts2
plot.forecast(rainseriesforecasts2)
library("forecast")
rainseriesforecasts2 <- forecast.HoltWinters(rainseriesforecasts, h=20) #future forecast 8 years
rainseriesforecasts2
plot.forecast(rainseriesforecasts2)
acf(rainseriesforecasts2$residuals, lag.max=4)
library("forecast")
rainseriesforecasts2 <- forecast.HoltWinters(rainseriesforecasts, h=8) #future forecast 8 years
rainseriesforecasts2
plot.forecast(rainseriesforecasts2) #80th percentile vs 95th percentile
acf(rainseriesforecasts2$residuals, lag.max=4)
acf(rainseriesforecasts2$residuals, lag.max=20)
#smoothing
library("TTR")
kingstimeseriesSMA3 <- SMA(kingstimeseries,n=3) #simple moving average 3, used when a lot of data and fluctuations are present
plot.ts(kingstimeseriesSMA3)
#exponential smoothing for short term forecasts
rain <- scan("http://robjhyndman.com/tsdldata/hurst/precip1.dat",skip=1)
rainseries <- ts(start=c(1813),rain)
plot.ts(rainseries)
rainseriesforecasts <- HoltWinters(rainseries, beta=FALSE, gamma=FALSE)
rainseriesforecasts
rainseriesforecasts$fitted
plot(rainseriesforecasts)
library("forecast")
rainseriesforecasts2 <- forecast.HoltWinters(rainseriesforecasts, h=8) #future forecast 8 years
rainseriesforecasts2
plot.forecast(rainseriesforecasts2) #80th percentile vs 95th percentile
acf(rainseriesforecasts2$residuals, lag.max=20) #correlogram of the in-sample forecast errors
Box.test(rainseriesforecasts2$residuals, lag=20, type="Ljung-Box")
plotForecastErrors <- function(forecasterrors)
{
# make a histogram of the forecast errors:
mybinsize <- IQR(forecasterrors)/4
mysd   <- sd(forecasterrors)
mymin  <- min(forecasterrors) - mysd*5
mymax  <- max(forecasterrors) + mysd*3
# generate normally distributed data with mean 0 and standard deviation mysd
mynorm <- rnorm(10000, mean=0, sd=mysd)
mymin2 <- min(mynorm)
mymax2 <- max(mynorm)
if (mymin2 < mymin) { mymin <- mymin2 }
if (mymax2 > mymax) { mymax <- mymax2 }
# make a red histogram of the forecast errors, with the normally distributed data overlaid:
mybins <- seq(mymin, mymax, mybinsize)
hist(forecasterrors, col="red", freq=FALSE, breaks=mybins)
# freq=FALSE ensures the area under the histogram = 1
# generate normally distributed data with mean 0 and standard deviation mysd
myhist <- hist(mynorm, plot=FALSE, breaks=mybins)
# plot the normal curve as a blue line on top of the histogram of forecast errors:
points(myhist$mids, myhist$density, type="l", col="blue", lwd=2)
}
plotForecastErrors(rainseriesforecasts2$residuals)
rain <- scan("http://robjhyndman.com/tsdldata/hurst/precip1.dat",skip=1)
rainseries <- ts(start=c(1813),rain)
plot.ts(rainseries)
rainseriesforecasts <- HoltWinters(rainseries, beta=FALSE, gamma=FALSE)
rainseriesforecasts
rainseriesforecasts$fitted
plot(rainseriesforecasts)
library("forecast")
rainseriesforecasts2 <- forecast.HoltWinters(rainseriesforecasts, h=8) #future forecast 8 years
rainseriesforecasts2
plot.forecast(rainseriesforecasts2) #80th percentile vs 95th percentile
#acf(rainseriesforecasts2$residuals, lag.max=20) #correlogram of the in-sample forecast errors
Box.test(rainseriesforecasts2$residuals, lag=20, type="Ljung-Box") #shows the p-value
#function : forecast errors are normally distributed
plotForecastErrors <- function(forecasterrors)
{
# make a histogram of the forecast errors:
mybinsize <- IQR(forecasterrors)/4
mysd   <- sd(forecasterrors)
mymin  <- min(forecasterrors) - mysd*5
mymax  <- max(forecasterrors) + mysd*3
# generate normally distributed data with mean 0 and standard deviation mysd
mynorm <- rnorm(10000, mean=0, sd=mysd)
mymin2 <- min(mynorm)
mymax2 <- max(mynorm)
if (mymin2 < mymin) { mymin <- mymin2 }
if (mymax2 > mymax) { mymax <- mymax2 }
# make a red histogram of the forecast errors, with the normally distributed data overlaid:
mybins <- seq(mymin, mymax, mybinsize)
hist(forecasterrors, col="red", freq=FALSE, breaks=mybins)
# freq=FALSE ensures the area under the histogram = 1
# generate normally distributed data with mean 0 and standard deviation mysd
myhist <- hist(mynorm, plot=FALSE, breaks=mybins)
# plot the normal curve as a blue line on top of the histogram of forecast errors:
points(myhist$mids, myhist$density, type="l", col="blue", lwd=2)
}
plotForecastErrors(rainseriesforecasts2$residuals)
plotForecastErrors(rainseriesforecasts2$residuals)
plotForecastErrors(rainseriesforecasts2$residuals)
function (x, probs = seq(0, 1, 0.25), na.rm = FALSE, names = TRUE,
type = 7, ...)
{
if (is.factor(x)) {
if (!is.ordered(x) || !type %in% c(1L, 3L))
stop("factors are not allowed")
lx <- levels(x)
}
else lx <- NULL
if (na.rm)
x <- x[!is.na(x)]
else if (anyNA(x))
stop("missing values and NaN's not allowed if 'na.rm' is FALSE")
eps <- 100 * .Machine$double.eps
if (any((p.ok <- !is.na(probs)) & (probs < -eps | probs >
1 + eps)))
stop("'probs' outside [0,1]")
n <- length(x)
if (na.p <- any(!p.ok)) {
o.pr <- probs
probs <- probs[p.ok]
probs <- pmax(0, pmin(1, probs))
}
np <- length(probs)
if (n > 0 && np > 0) {
if (type == 7) {
index <- 1 + (n - 1) * probs
lo <- floor(index)
hi <- ceiling(index)
x <- sort(x, partial = unique(c(lo, hi)))
qs <- x[lo]
i <- which(index > lo)
h <- (index - lo)[i]
qs[i] <- (1 - h) * qs[i] + h * x[hi[i]]
}
else {
if (type <= 3) {
nppm <- if (type == 3)
n * probs - 0.5
else n * probs
j <- floor(nppm)
h <- switch(type, (nppm > j), ((nppm > j) +
1)/2, (nppm != j) | ((j%%2L) == 1L))
}
else {
switch(type - 3, {
a <- 0
b <- 1
}, a <- b <- 0.5, a <- b <- 0, a <- b <- 1,
a <- b <- 1/3, a <- b <- 3/8)
fuzz <- 4 * .Machine$double.eps
nppm <- a + probs * (n + 1 - a - b)
j <- floor(nppm + fuzz)
h <- nppm - j
if (any(sml <- abs(h) < fuzz))
h[sml] <- 0
}
x <- sort(x, partial = unique(c(1, j[j > 0L & j <=
n], (j + 1)[j > 0L & j < n], n)))
x <- c(x[1L], x[1L], x, x[n], x[n])
qs <- x[j + 2L]
qs[h == 1] <- x[j + 3L][h == 1]
other <- (0 < h) & (h < 1)
if (any(other))
qs[other] <- ((1 - h) * x[j + 2L] + h * x[j +
3L])[other]
}
}
else {
qs <- rep(NA_real_, np)
}
if (is.character(lx))
qs <- factor(qs, levels = seq_along(lx), labels = lx,
ordered = TRUE)
if (names && np > 0L) {
names(qs) <- format_perc(probs)
}
if (na.p) {
o.pr[p.ok] <- qs
names(o.pr) <- rep("", length(o.pr))
names(o.pr)[p.ok] <- names(qs)
o.pr
}
else qs
}
plotForecastErrors(rainseriesforecasts2$residuals)
plotForecastErrors(rainseriesforecasts2$residuals)
function (x, probs = seq(0, 1, 0.25), na.rm = FALSE, names = TRUE,
type = 7, ...)
{
if (is.factor(x)) {
if (!is.ordered(x) || !type %in% c(1L, 3L))
stop("factors are not allowed")
lx <- levels(x)
}
else lx <- NULL
if (na.rm)
x <- x[!is.na(x)]
else if (anyNA(x))
stop("missing values and NaN's not allowed if 'na.rm' is FALSE")
eps <- 100 * .Machine$double.eps
if (any((p.ok <- !is.na(probs)) & (probs < -eps | probs >
1 + eps)))
stop("'probs' outside [0,1]")
n <- length(x)
if (na.p <- any(!p.ok)) {
o.pr <- probs
probs <- probs[p.ok]
probs <- pmax(0, pmin(1, probs))
}
np <- length(probs)
if (n > 0 && np > 0) {
if (type == 7) {
index <- 1 + (n - 1) * probs
lo <- floor(index)
hi <- ceiling(index)
x <- sort(x, partial = unique(c(lo, hi)))
qs <- x[lo]
i <- which(index > lo)
h <- (index - lo)[i]
qs[i] <- (1 - h) * qs[i] + h * x[hi[i]]
}
else {
if (type <= 3) {
nppm <- if (type == 3)
n * probs - 0.5
else n * probs
j <- floor(nppm)
h <- switch(type, (nppm > j), ((nppm > j) +
1)/2, (nppm != j) | ((j%%2L) == 1L))
}
else {
switch(type - 3, {
a <- 0
b <- 1
}, a <- b <- 0.5, a <- b <- 0, a <- b <- 1,
a <- b <- 1/3, a <- b <- 3/8)
fuzz <- 4 * .Machine$double.eps
nppm <- a + probs * (n + 1 - a - b)
j <- floor(nppm + fuzz)
h <- nppm - j
if (any(sml <- abs(h) < fuzz))
h[sml] <- 0
}
x <- sort(x, partial = unique(c(1, j[j > 0L & j <=
n], (j + 1)[j > 0L & j < n], n)))
x <- c(x[1L], x[1L], x, x[n], x[n])
qs <- x[j + 2L]
qs[h == 1] <- x[j + 3L][h == 1]
other <- (0 < h) & (h < 1)
if (any(other))
qs[other] <- ((1 - h) * x[j + 2L] + h * x[j +
3L])[other]
}
}
else {
qs <- rep(NA_real_, np)
}
if (is.character(lx))
qs <- factor(qs, levels = seq_along(lx), labels = lx,
ordered = TRUE)
if (names && np > 0L) {
names(qs) <- format_perc(probs)
}
if (na.p) {
o.pr[p.ok] <- qs
names(o.pr) <- rep("", length(o.pr))
names(o.pr)[p.ok] <- names(qs)
o.pr
}
else qs
}
plotForecastErrors(rainseriesforecasts2$residuals)
plotForecastErrors(rainseriesforecasts2$residuals)
plotForecastErrors(rainseriesforecasts2$residuals)
plotForecastErrors(rainseriesforecasts2$residuals)
plotForecastErrors(rainseriesforecasts2$residuals)
plotForecastErrors(rainseriesforecasts2$residuals)
library("forecast")
rainseriesforecasts2 <- forecast.HoltWinters(rainseriesforecasts, h=8) #future forecast 8 years
rainseriesforecasts2
plot.forecast(rainseriesforecasts2) #80th percentile vs 95th percentile
#acf(rainseriesforecasts2$residuals, lag.max=20) #correlogram of the in-sample forecast errors
Box.test(rainseriesforecasts2$residuals, lag=20, type="Ljung-Box") #shows the p-value
#function : forecast errors are normally distributed
plotForecastErrors <- function(forecasterrors)
{
plot(forecasterrors)
# make a histogram of the forecast errors:
mybinsize <- IQR(forecasterrors,na.rm=FALSE)/4
mybinsize
mysd   <- sd(forecasterrors)
mymin  <- min(forecasterrors) - mysd*5
mymax  <- max(forecasterrors) + mysd*3
# generate normally distributed data with mean 0 and standard deviation mysd
mynorm <- rnorm(10000, mean=0, sd=mysd)
mymin2 <- min(mynorm)
mymax2 <- max(mynorm)
if (mymin2 < mymin) { mymin <- mymin2 }
if (mymax2 > mymax) { mymax <- mymax2 }
# make a red histogram of the forecast errors, with the normally distributed data overlaid:
mybins <- seq(mymin, mymax, mybinsize)
hist(forecasterrors, col="red", freq=FALSE, breaks=mybins)
# freq=FALSE ensures the area under the histogram = 1
# generate normally distributed data with mean 0 and standard deviation mysd
myhist <- hist(mynorm, plot=FALSE, breaks=mybins)
# plot the normal curve as a blue line on top of the histogram of forecast errors:
points(myhist$mids, myhist$density, type="l", col="blue", lwd=2)
}
plotForecastErrors(rainseriesforecasts2$residuals)
plotForecastErrors <- function(forecasterrors)
{
# make a histogram of the forecast errors:
mybinsize <- IQR(forecasterrors,na.rm=FALSE)/4
mybinsize
mysd   <- sd(forecasterrors)
mymin  <- min(forecasterrors) - mysd*5
mymax  <- max(forecasterrors) + mysd*3
# generate normally distributed data with mean 0 and standard deviation mysd
mynorm <- rnorm(10000, mean=0, sd=mysd)
mymin2 <- min(mynorm)
mymax2 <- max(mynorm)
if (mymin2 < mymin) { mymin <- mymin2 }
if (mymax2 > mymax) { mymax <- mymax2 }
# make a red histogram of the forecast errors, with the normally distributed data overlaid:
mybins <- seq(mymin, mymax, mybinsize)
hist(forecasterrors, col="red", freq=FALSE, breaks=mybins)
# freq=FALSE ensures the area under the histogram = 1
# generate normally distributed data with mean 0 and standard deviation mysd
myhist <- hist(mynorm, plot=FALSE, breaks=mybins)
# plot the normal curve as a blue line on top of the histogram of forecast errors:
points(myhist$mids, myhist$density, type="l", col="blue", lwd=2)
}
plot(rainseriesforecasts2$residuals)
plotForecastErrors(rainseriesforecasts2$residuals)
plotForecastErrors <- function(forecasterrors)
{
# make a histogram of the forecast errors:
mybinsize <- IQR(forecasterrors,na.rm=FALSE)/4
mybinsize
mysd   <- sd(forecasterrors)
mymin  <- min(forecasterrors) - mysd*5
mymax  <- max(forecasterrors) + mysd*3
# generate normally distributed data with mean 0 and standard deviation mysd
mynorm <- rnorm(10000, mean=0, sd=mysd)
mymin2 <- min(mynorm)
mymax2 <- max(mynorm)
if (mymin2 < mymin) { mymin <- mymin2 }
if (mymax2 > mymax) { mymax <- mymax2 }
# make a red histogram of the forecast errors, with the normally distributed data overlaid:
mybins <- seq(mymin, mymax, mybinsize)
hist(forecasterrors, col="red", freq=FALSE, breaks=mybins)
# freq=FALSE ensures the area under the histogram = 1
# generate normally distributed data with mean 0 and standard deviation mysd
myhist <- hist(mynorm, plot=FALSE, breaks=mybins)
# plot the normal curve as a blue line on top of the histogram of forecast errors:
points(myhist$mids, myhist$density, type="l", col="blue", lwd=2)
}
plot.ts(rainseriesforecasts2$residuals)
plotForecastErrors(rainseriesforecasts2$residuals)
Box.test(rainseriesforecasts2$residuals, lag=20, type="Ljung-Box")
IQR(rainseriesforecasts2$residuals)
rainseriesforecasts2$residuals
na.omit(rainseriesforecasts2$residuals)
IQR(na.omit(rainseriesforecasts2$residuals))
plotForecastErrors(na.omit(rainseriesforecasts2$residuals))
skirts <- scan("http://robjhyndman.com/tsdldata/roberts/skirts.dat",skip=5)
skirtsseries <- ts(skirts,start=c(1866))
plot.ts(skirtsseries)
skirtsseriesforecasts <- HoltWinters(skirtsseries, gamma=FALSE)
skirtsseries <- ts(skirts,start=c(1866))
plot.ts(skirtsseries)
skirtsseriesforecasts <- HoltWinters(skirtsseries, gamma=FALSE)
skirtsseriesforecasts
skirtsseriesforecasts <- HoltWinters(skirtsseries, gamma=FALSE)
skirtsseriesforecasts
plot(skirtsseriesforecasts)
plot.ts(skirtsseries)
skirtsseriesforecasts <- HoltWinters(skirtsseries, gamma=FALSE,beta=TRUE)
skirtsseriesforecasts
plot(skirtsseriesforecasts)
HoltWinters(skirtsseries, gamma=FALSE, l.start=608, b.start=9)
HoltWinters(skirtsseries, gamma=FALSE, l.start=608, b.start=9)
skirtsseriesforecasts2 <- forecast.HoltWinters(skirtsseriesforecasts, h=19)
plot.forecast(skirtsseriesforecasts2)
load("D:/Masters/MCS-DS/Applied machine learning/cs498-master/homework1/3_1ab.R")
setwd("D:/Masters/MCS-DS/Applied machine learning/Homeworks/AML-Projects/homework6")
names <- c("crim","zn","indus","chas","nox","rm","age","dis","rad","tax","ptratio","black","lstat","medv")
data <- read.table("housing.data", header=F, col.names = names)
#colnames(data) <- c("crim","zn","indus","chas","nox","rm","age","dis","rad","tax","ptratio","black","lstat","medv")
summary(data)
head(data)
#regress only over the black variable
lr_against_black=lm(medv~black,data=data)
summary(lr_against_black)
#par(mfrow=c(2,2))
plot(lr_against_black)
library(MASS)
library(ISLR)
setwd("D:/Masters/MCS-DS/Applied machine learning/Homeworks/AML-Projects/homework6")
names <- c("crim","zn","indus","chas","nox","rm","age","dis","rad","tax","ptratio","black","lstat","medv")
data <- read.table("housing.data", header=F, col.names = names)
#colnames(data) <- c("crim","zn","indus","chas","nox","rm","age","dis","rad","tax","ptratio","black","lstat","medv")
summary(data)
head(data)
#regress only over the black variable
lr_against_black=lm(medv~black,data=data)
summary(lr_against_black)
par(mfrow=c(2,2))
plot(lr_against_black)
library(MASS)
library(ISLR)
setwd("D:/Masters/MCS-DS/Applied machine learning/Homeworks/AML-Projects/homework6")
names <- c("crim","zn","indus","chas","nox","rm","age","dis","rad","tax","ptratio","black","lstat","medv")
data <- read.table("housing.data", header=F, col.names = names)
#colnames(data) <- c("crim","zn","indus","chas","nox","rm","age","dis","rad","tax","ptratio","black","lstat","medv")
summary(data)
head(data)
#regress only over the black variable
lr_against_black=lm(medv~black,data=data)
summary(lr_against_black)
par(mfrow=c(2,2))
plot(lr_against_black)
plot(medv~black,data)
abline(lr_against_black,col="red")
multi_lr=lm(medv~crim+zn+indus+chas+nox+rm+age+dis+rad+tax+ptratio+black+lstat,data)
summary(multi_lr)
plot(multi_lr)
library(MASS)
library(ISLR)
setwd("D:/Masters/MCS-DS/Applied machine learning/Homeworks/AML-Projects/homework6")
names <- c("crim","zn","indus","chas","nox","rm","age","dis","rad","tax","ptratio","black","lstat","medv")
data <- read.table("housing.data", header=F, col.names = names)
#colnames(data) <- c("crim","zn","indus","chas","nox","rm","age","dis","rad","tax","ptratio","black","lstat","medv")
summary(data)
head(data)
#regress only over the black variable
lr_against_black=lm(medv~black,data=data)
summary(lr_against_black)
par(mfrow=c(2,2))
plot(lr_against_black)
plot(medv~black,data)
abline(lr_against_black,col="red")
#regress over all the attributes
multi_lr=lm(medv~crim+zn+indus+chas+nox+rm+age+dis+rad+tax+ptratio+black+lstat,data)
summary(multi_lr)
plot(multi_lr)
data[365]
data[:365]
data[,365]
data[365,]
data[1,]
head(data)
summary(data)
data[373,]
data[369,]
data_without_outliers <- myData[-c(365, 369, 373), ]
data_without_outliers <- data[-c(365, 369, 373), ]
data_without_outliers
multi_lr_no_outliers=lm(medv~crim+zn+indus+chas+nox+rm+age+dis+rad+tax+ptratio+black+lstat,data_without_outliers)
summary(multi_lr_no_outliers)
plot(multi_lr_no_outliers)
summary(data_without_outliers)
